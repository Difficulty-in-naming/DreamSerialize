<#@ template debug="false" hostspecific="false" language="C#" #>
// <auto-generated />
#if FAT

using System;
using System.Collections.Generic;

namespace Theraot.Core
{<#
    for (var indice = 1; indice < 9; indice++)
    {
#>

    class TupleEqualityComparer<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#> : IEqualityComparer<Tuple<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#>>
    {
        private static readonly TupleEqualityComparer<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#> _default;

<#
        if (indice == 1)
        {
#>
        private readonly IEqualityComparer<T> _comparer;
<#
        }
        else
        {
            for (var subindice = 1; subindice <= indice; subindice++)
            {
#>
        private readonly IEqualityComparer<T<#=subindice#>> _comparer<#=subindice#>;
<#
            }
        }
#>

        static TupleEqualityComparer()
        {
            _default = new TupleEqualityComparer<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#>();
        }

        public TupleEqualityComparer(<# if (indice != 0) {#><# if (indice == 1) #>IEqualityComparer<T> comparer<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>IEqualityComparer<T<#=subindice#>> comparer<#=subindice#><#}#><#}#>)
        {
<#
            if (indice == 1)
            {
#>
            _comparer = comparer ?? EqualityComparerHelper<T>.Default;
<#
            }
            else
            {
                for (var subindice = 1; subindice <= indice; subindice++)
                {
#>
            _comparer<#=subindice#> = comparer<#=subindice#> ?? EqualityComparerHelper<T<#=subindice#>>.Default;
<#
                }
            }
#>
        }

        private TupleEqualityComparer()
        {
<#
            if (indice == 1)
            {
#>
            _comparer = EqualityComparerHelper<T>.Default;
<#
            }
            else
            {
                for (var subindice = 1; subindice <= indice; subindice++)
                {
#>
            _comparer<#=subindice#> = EqualityComparerHelper<T<#=subindice#>>.Default;
<#
                }
            }
#>
        }

        public static TupleEqualityComparer<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#> Default
        {
            get
            {
                return _default;
            }
        }

        public bool Equals(Tuple<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#> x, Tuple<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#> y)
        {
            if (ReferenceEquals(x, y))
            {
                return true;
            }
            else if (ReferenceEquals(null, x) || ReferenceEquals(null, y))
            {
                return false;
            }
            else
            {
                return
<#
                if (indice == 1)
                {
#>
                    _comparer.Equals(x.Item1, y.Item1);
<#
                }
                else
                {
                    for (var subindice = 1; subindice <= indice; subindice++)
                    {
                        if(subindice == indice)
                        {
                            if (indice == 8)
                            {
#>
                    _comparer<#=subindice#>.Equals(x.Rest, y.Rest);
<#
                            }
                            else
                            {
#>
                    _comparer<#=subindice#>.Equals(x.Item<#=subindice#>, y.Item<#=subindice#>);
<#
                            }
                        }
                        else
                        {
#>
                    _comparer<#=subindice#>.Equals(x.Item<#=subindice#>, y.Item<#=subindice#>) &&
<#
                        }
                    }
                }
#>
            }
        }

        public int GetHashCode(Tuple<# if (indice != 0) {#><<# if (indice == 1) #>T<# else for (var subindice = 1; subindice <= indice; subindice++){ if (subindice != 1) {#>, <#}#>T<#=subindice#><#}#>><#}#> obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return EqualityComparer<object>.Default.GetHashCode(null);
            }
            else unchecked
            {
                return
<#
                if (indice == 1)
                {
#>
                    _comparer.GetHashCode(obj.Item1);
<#
                }
                else
                {
                    for (var subindice = 1; subindice <= indice; subindice++)
                    {
                        if(subindice == indice)
                        {
                            if (indice == 8)
                            {
#>
                    _comparer<#=subindice#>.GetHashCode(obj.Rest);
<#
                            }
                            else
                            {
#>
                    _comparer<#=subindice#>.GetHashCode(obj.Item<#=subindice#>);
<#
                            }
                        }
                        else
                        {
#>
                    (_comparer<#=subindice#>.GetHashCode(obj.Item<#=subindice#>) * 17) +
<#
                        }
                    }
                }
#>
            }
        }
    }
<#
    }
#>}

#endif